# Phase 2: Page Object Model (POM) Generation

## Purpose

Generate Page Object Model classes from explored DOM elements, following team-specific patterns and standards, with verified selectors and comprehensive action/getter methods.

## Prerequisites

Phase 1 has completed:
- ✓ Browser session initialized and authenticated
- ✓ DOM exploration completed for all pages
- ✓ Selectors captured and verified
- ✓ Elements grouped by component/functionality

## Step 1: Load POM Pattern Template

### Reference Team Configuration

```
✓ Loading POM configuration...
✓ Base page pattern: full (from config)
✓ Selector grouping: enabled
✓ Assertion helpers: disabled
```

I'll use the POM pattern settings from your configuration or defaults:
- BasePage pattern (minimal, full, or custom)
- Selector organization strategy
- Whether to include assertion helper methods
- Custom BasePage path (if specified)

### Load Template Structure

```
✓ Loading POM template from: pom-pattern-template.ts
✓ Template structure validated
✓ Ready to generate page objects
```

I'll reference the template at:
- `agent-os/specs/2025-12-01-playwright-test-automation/implementation/pom-pattern-template.ts`

Or your custom template if specified in configuration.

## Step 2: Generate BasePage Class

### Create Base Class with Common Utilities

```
✓ Generating BasePage.ts...
✓ Including common navigation helpers
✓ Including interaction helpers
✓ Including wait helpers
✓ Including validation helpers
```

**BasePage.ts structure:**

```typescript
import { Page, Locator } from '@playwright/test';

/**
 * BasePage - Base class for all Page Objects
 *
 * Provides common utilities and helper methods shared across all pages.
 * All page objects should extend this class.
 *
 * Generated by QA Agent OS /automate-testcases
 * Standards: @qa-agent-os/standards/automation/pom-patterns.md
 */
export abstract class BasePage {
  protected readonly page: Page;

  constructor(page: Page) {
    this.page = page;
  }

  // ===== NAVIGATION HELPERS =====

  protected async navigateTo(url: string): Promise<void> {
    await this.page.goto(url);
    await this.page.waitForLoadState('networkidle');
  }

  protected async navigateWithToken(url: string, token: string): Promise<void> {
    await this.page.goto(`${url}?auth_token=${token}`);
    await this.page.waitForLoadState('networkidle');
  }

  // ===== INTERACTION HELPERS =====

  protected async fillInput(locator: Locator, value: string): Promise<void> {
    await locator.clear();
    await locator.fill(value);
  }

  protected async clickAndWait(locator: Locator, waitForSelector?: string): Promise<void> {
    await locator.click();
    if (waitForSelector) {
      await this.page.waitForSelector(waitForSelector);
    }
  }

  // ===== WAIT HELPERS =====

  protected async waitForElement(selector: string, timeout = 10000): Promise<void> {
    await this.page.waitForSelector(selector, { timeout });
  }

  protected async waitForNetworkIdle(): Promise<void> {
    await this.page.waitForLoadState('networkidle');
  }

  // ===== GETTER HELPERS =====

  protected async getText(locator: Locator): Promise<string> {
    return await locator.textContent() || '';
  }

  protected async isVisible(locator: Locator): Promise<boolean> {
    return await locator.isVisible();
  }

  // ===== VALIDATION HELPERS =====

  protected async expectElementVisible(locator: Locator): Promise<void> {
    await locator.waitFor({ state: 'visible' });
  }

  protected async expectElementHidden(locator: Locator): Promise<void> {
    await locator.waitFor({ state: 'hidden' });
  }
}
```

### Customize BasePage Based on Configuration

**If config specifies minimal pattern:**
- Include only essential navigation and wait helpers

**If config specifies full pattern:**
- Include comprehensive utilities as shown above

**If config specifies custom BasePage:**
```
✓ Using custom BasePage: ./utils/custom-base-page.ts
✓ Custom BasePage will be imported by page objects
```

## Step 3: Generate Page Object Classes

### For Each Page Explored

I'll generate one POM class per page/component from Phase 1 exploration.

#### Example: Login Page POM

```
✓ Generating LoginPage.ts...
✓ Importing BasePage
✓ Creating SELECTORS object with groups
✓ Defining public locators for assertions
✓ Creating constructor with locator initialization
✓ Adding navigation methods
✓ Adding action methods based on element types
✓ Adding getter methods for data retrieval
✓ Adding wait condition methods
✓ File saved: automated-tests/pom/LoginPage.ts
```

**Generated LoginPage.ts:**

```typescript
import { Page, Locator } from '@playwright/test';
import { BasePage } from './BasePage';

/**
 * LoginPage - Represents the application login page
 *
 * URL: /login
 * Purpose: Handles user authentication functionality
 *
 * Common actions:
 * - login(username, password): Authenticates user with credentials
 * - loginWithRememberMe(username, password): Authenticates with remember me option
 * - clickForgotPassword(): Navigates to password reset flow
 *
 * Source: features/user-auth/WYX-123/feature-knowledge.md > User Authentication
 * Generated: 2025-12-02 by /automate-testcases
 * Standards: @qa-agent-os/standards/automation/pom-patterns.md
 */
export class LoginPage extends BasePage {
  // SELECTORS: Define all element selectors grouped by functionality
  private readonly SELECTORS = {
    form: {
      usernameInput: '[data-testid="username-input"]',  // Priority: data-testid
      passwordInput: '#password',                        // Priority: id
      rememberMeCheckbox: '[data-testid="remember-me"]',
      submitButton: 'button:has-text("Sign In")'        // Complex: Multiple buttons, text distinguishes
    },
    messages: {
      errorMessage: '.error-message',                    // Priority: semantic class
      successMessage: '.success-message'
    },
    links: {
      forgotPassword: 'a[href="/forgot-password"]',
      signUp: '[data-testid="signup-link"]'
    }
  };

  // PUBLIC LOCATORS: Exposed for test assertions
  readonly errorMessage: Locator;
  readonly successMessage: Locator;
  readonly submitButton: Locator;

  constructor(page: Page) {
    super(page);

    // Initialize public locators
    this.errorMessage = page.locator(this.SELECTORS.messages.errorMessage);
    this.successMessage = page.locator(this.SELECTORS.messages.successMessage);
    this.submitButton = page.locator(this.SELECTORS.form.submitButton);
  }

  // NAVIGATION METHODS

  /**
   * Navigate to the login page
   */
  async navigate(): Promise<void> {
    await this.navigateTo('/login');
    await this.waitForPageLoad();
  }

  // ACTION METHODS: Represent user interactions

  /**
   * Log in with username and password
   *
   * @param username - User's email or username
   * @param password - User's password
   */
  async login(username: string, password: string): Promise<void> {
    await this.fillInput(
      this.page.locator(this.SELECTORS.form.usernameInput),
      username
    );
    await this.fillInput(
      this.page.locator(this.SELECTORS.form.passwordInput),
      password
    );
    await this.page.locator(this.SELECTORS.form.submitButton).click();
  }

  /**
   * Log in with username, password, and remember me option
   *
   * @param username - User's email or username
   * @param password - User's password
   */
  async loginWithRememberMe(username: string, password: string): Promise<void> {
    await this.fillInput(
      this.page.locator(this.SELECTORS.form.usernameInput),
      username
    );
    await this.fillInput(
      this.page.locator(this.SELECTORS.form.passwordInput),
      password
    );
    await this.page.locator(this.SELECTORS.form.rememberMeCheckbox).check();
    await this.page.locator(this.SELECTORS.form.submitButton).click();
  }

  /**
   * Click forgot password link
   */
  async clickForgotPassword(): Promise<void> {
    await this.page.locator(this.SELECTORS.links.forgotPassword).click();
  }

  /**
   * Click sign up link
   */
  async clickSignUp(): Promise<void> {
    await this.page.locator(this.SELECTORS.links.signUp).click();
  }

  /**
   * Clear the login form
   */
  async clearForm(): Promise<void> {
    await this.page.locator(this.SELECTORS.form.usernameInput).clear();
    await this.page.locator(this.SELECTORS.form.passwordInput).clear();
  }

  // GETTER METHODS: Retrieve page state/data

  /**
   * Get the error message text
   *
   * @returns Error message content or empty string if not present
   */
  async getErrorMessage(): Promise<string> {
    return await this.getText(this.errorMessage);
  }

  /**
   * Check if login button is enabled
   *
   * @returns True if button is enabled, false otherwise
   */
  async isLoginButtonEnabled(): Promise<boolean> {
    return await this.submitButton.isEnabled();
  }

  /**
   * Check if remember me is checked
   *
   * @returns True if checkbox is checked, false otherwise
   */
  async isRememberMeChecked(): Promise<boolean> {
    return await this.page.locator(this.SELECTORS.form.rememberMeCheckbox).isChecked();
  }

  // WAIT CONDITION METHODS

  /**
   * Wait for error message to appear
   */
  async waitForErrorMessage(): Promise<void> {
    await this.errorMessage.waitFor({ state: 'visible' });
  }

  /**
   * Wait for success message to appear
   */
  async waitForSuccessMessage(): Promise<void> {
    await this.successMessage.waitFor({ state: 'visible' });
  }

  /**
   * Wait for login page to fully load
   */
  private async waitForPageLoad(): Promise<void> {
    await this.page.waitForSelector(this.SELECTORS.form.usernameInput);
  }
}
```

### Method Generation Logic

**Action Methods (based on element types):**
- Input fields → `fill[FieldName]()` methods
- Buttons → `click[ButtonName]()` methods
- Checkboxes → `check/uncheck[CheckboxName]()` methods
- Dropdowns → `select[DropdownName]()` methods
- Links → `click[LinkName]()` methods

**Getter Methods (based on element purposes):**
- Text elements → `get[ElementName]Text()` methods
- State checks → `is[ElementName]Visible/Enabled/Checked()` methods
- Data retrieval → `get[DataName]()` methods

**Wait Methods:**
- Visibility waits → `waitFor[ElementName]()` methods
- Page load waits → `waitForPageLoad()` private methods

## Step 4: Verify Selectors Against Live DOM

### Re-verify All Selectors

```
✓ Verifying LoginPage selectors...
✓ Testing: [data-testid="username-input"] → Found
✓ Testing: #password → Found
✓ Testing: button:has-text("Sign In") → Found
✓ All LoginPage selectors verified

✓ Verifying DashboardPage selectors...
✓ Testing: [data-testid="user-name"] → Found
✓ Testing: [data-testid="logout"] → Found
✓ All DashboardPage selectors verified

✓ All POM selectors verified against live DOM
```

**If selector fails verification:**
```
⚠️  Selector verification failed: .submit-button

Element not found on page. Possible issues:
  - Element is conditionally rendered
  - Selector changed since exploration
  - Element requires interaction to appear

Action taken:
  ✓ Using fallback selector: button[type="submit"]
  ✓ Added comment explaining selector choice
```

## Step 5: Apply Standards Compliance

### Check Against POM Standards

```
✓ Verifying standards compliance...
✓ Checking: All classes extend BasePage
✓ Checking: Selectors in SELECTORS object
✓ Checking: Selector priority followed
✓ Checking: Public locators for assertions
✓ Checking: Method naming conventions
✓ Checking: No hardcoded values
✓ Checking: Documentation comments present
✓ All standards checks passed
```

**Standards enforced:**
- `@qa-agent-os/standards/automation/pom-patterns.md` - POM structure
- `@qa-agent-os/standards/global/coding-style.md` - TypeScript conventions
- `@qa-agent-os/standards/global/commenting.md` - Documentation requirements

**If standards violation detected:**
```
⚠️  Standards violation: Hardcoded URL in navigation method

Expected: await this.navigateTo('/login');
Found: await this.page.goto('http://localhost:3000/login');

Action taken:
  ✓ Corrected to use relative URL
  ✓ Added comment referencing standards
```

## Step 6: Generate Component Page Objects (if needed)

### Identify Reusable Components

```
✓ Analyzing for reusable components...
✓ Found: Modal dialogs on multiple pages
✓ Found: Navigation menu on all pages
✓ Generating component page objects...
```

#### Example: Modal Component

```typescript
/**
 * ModalComponent - Represents reusable modal dialog
 *
 * Used on: Dashboard, Profile, Settings pages
 * Purpose: Common modal interaction patterns
 */
export class ModalComponent extends BasePage {
  private readonly SELECTORS = {
    container: '.modal-overlay',
    dialog: '[role="dialog"]',
    title: '.modal-title',
    closeButton: '[data-testid="modal-close"]',
    confirmButton: '[data-testid="modal-confirm"]',
    cancelButton: '[data-testid="modal-cancel"]'
  };

  readonly title: Locator;
  readonly confirmButton: Locator;

  constructor(page: Page) {
    super(page);
    this.title = page.locator(this.SELECTORS.title);
    this.confirmButton = page.locator(this.SELECTORS.confirmButton);
  }

  async waitForModal(): Promise<void> {
    await this.page.locator(this.SELECTORS.container).waitFor({ state: 'visible' });
  }

  async close(): Promise<void> {
    await this.page.locator(this.SELECTORS.closeButton).click();
    await this.page.locator(this.SELECTORS.container).waitFor({ state: 'hidden' });
  }

  async confirm(): Promise<void> {
    await this.confirmButton.click();
  }

  async cancel(): Promise<void> {
    await this.page.locator(this.SELECTORS.cancelButton).click();
  }

  async getTitle(): Promise<string> {
    return await this.getText(this.title);
  }
}
```

**Component saved to:** `automated-tests/pom/components/ModalComponent.ts`

## Step 7: POM Generation Summary

```
════════════════════════════════════════════════════════════
  POM Generation Summary
════════════════════════════════════════════════════════════

Generated Page Objects: 4

BasePage.ts
  ├── Navigation helpers: 2 methods
  ├── Interaction helpers: 2 methods
  ├── Wait helpers: 2 methods
  ├── Getter helpers: 2 methods
  └── Validation helpers: 2 methods

LoginPage.ts
  ├── Selectors: 8 elements in 3 groups
  ├── Action methods: 5 methods
  ├── Getter methods: 3 methods
  ├── Wait methods: 3 methods
  └── All selectors verified ✓

DashboardPage.ts
  ├── Selectors: 15 elements in 3 groups
  ├── Action methods: 8 methods
  ├── Getter methods: 5 methods
  ├── Wait methods: 4 methods
  └── All selectors verified ✓

ProfilePage.ts
  ├── Selectors: 8 elements in 2 groups
  ├── Action methods: 6 methods
  ├── Getter methods: 4 methods
  ├── Wait methods: 2 methods
  └── All selectors verified ✓

Components:
  ├── ModalComponent.ts
  └── NavigationComponent.ts

Standards Compliance: 100% ✓
Selector Quality: Excellent (80% data-testid/id)
Documentation: Complete ✓

Files saved to: automated-tests/pom/

════════════════════════════════════════════════════════════
```

## Step 8: Validate Generated POMs

### TypeScript Compilation Check

```
✓ Checking TypeScript syntax...
✓ All imports valid
✓ All type definitions correct
✓ No compilation errors
✓ POMs ready for use
```

**If TypeScript errors found:**
```
❌ TypeScript compilation errors:

  LoginPage.ts:45:12 - error TS2345: Argument of type 'string | null'
  is not assignable to parameter of type 'string'.

Action taken:
  ✓ Fixed with null coalescing operator
  ✓ Re-validated TypeScript
  ✓ All errors resolved
```

## Error Handling

### Selector Not Found During Verification

```
⚠️  Selector not found: [data-testid="submit-button"]

Attempting fallback:
  ✓ Trying: button[type="submit"]
  ✓ Found with fallback selector
  ✓ Updated POM with fallback and comment
```

### Method Generation Ambiguity

```
⚠️  Multiple buttons with same purpose detected

Original: clickButton()
Refined: clickSubmitButton(), clickCancelButton()

✓ Methods disambiguated with clearer names
```

### Import Path Issues

```
⚠️  Import path may be incorrect: ../BasePage

Validating:
  ✓ Checking relative path from pom/LoginPage.ts
  ✓ Correct path: ./BasePage
  ✓ Import path corrected
```

## Next Phase

With POM generation complete, I'll proceed to Phase 3: Test Script Generation.

**Generated POMs ready for:**
- Test script imports
- Action method calls in test scenarios
- Assertion using public locators
- Reuse across multiple test files
