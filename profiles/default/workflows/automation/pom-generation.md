# Page Object Model (POM) Generation Workflow

This workflow details the process of generating Page Object Model classes from explored DOM elements, following team-specific patterns and standards, with verified selectors and comprehensive action/getter methods.

## Core Responsibilities

1. **BasePage Generation**: Create base class with common utilities
2. **POM Class Generation**: Generate one POM class per page/component
3. **Selector Organization**: Group selectors in SELECTORS object
4. **Method Generation**: Create action, getter, and wait methods
5. **Selector Verification**: Re-verify selectors against live DOM
6. **Standards Compliance**: Enforce POM pattern standards
7. **Component Extraction**: Identify and create reusable components

---

## Input from DOM Exploration

### Exploration Data Structure

The workflow receives structured data from DOM exploration:

```typescript
interface PageExplorationData {
  name: string;              // e.g., "LoginPage"
  url: string;               // e.g., "/login"
  elements: Array<{
    name: string;            // e.g., "usernameInput"
    selector: string;        // e.g., '[data-testid="username-input"]'
    type: string;            // e.g., "input[type='text']"
    purpose: string;         // e.g., "User input for username"
    priority: string;        // e.g., "data-testid"
    group: string;           // e.g., "form"
    reasoning?: string;      // Optional explanation for complex selectors
  }>;
  groups: Record<string, string[]>;  // e.g., { form: ["usernameInput", "passwordInput"] }
}
```

---

## Step 1: Load POM Pattern Template

### Reference Team Configuration

**Configuration sources (in priority order):**
1. Team-specific config: `qa-agent-os/config/automation/pom-pattern.md`
2. Project template: `[project-root]/pom-pattern-template.ts`
3. QA Agent OS default: `pom-pattern-template.ts` (in implementation/)

**Load pattern settings:**
```
✓ Loading POM configuration...
✓ Base page pattern: full (from config)
✓ Selector grouping: enabled
✓ Assertion helpers: disabled
✓ Custom BasePage path: Not specified (using default)
```

**Pattern options:**
- **minimal**: Essential navigation and wait helpers only
- **full**: Comprehensive utilities (navigation, interaction, wait, getter, validation)
- **custom**: Use team-specific BasePage at specified path

---

## Step 2: Generate BasePage Class

### BasePage Structure

**Core components:**
1. Protected `page` property
2. Navigation helpers (goto, navigateWithToken)
3. Interaction helpers (fillInput, clickAndWait)
4. Wait helpers (waitForElement, waitForNetworkIdle)
5. Getter helpers (getText, isVisible)
6. Validation helpers (expectElementVisible, expectElementHidden)

### Generation Process

```
✓ Generating BasePage.ts...
✓ Including common navigation helpers
✓ Including interaction helpers
✓ Including wait helpers
✓ Including getter helpers
✓ Including validation helpers
✓ File saved: automated-tests/pom/BasePage.ts
```

### BasePage Template (Full Pattern)

```typescript
import { Page, Locator } from '@playwright/test';

/**
 * BasePage - Base class for all Page Objects
 *
 * Provides common utilities and helper methods shared across all pages.
 * All page objects should extend this class.
 *
 * Generated by QA Agent OS /automate-testcases
 * Standards: @qa-agent-os/standards/automation/pom-patterns.md
 */
export abstract class BasePage {
  protected readonly page: Page;

  constructor(page: Page) {
    this.page = page;
  }

  // ===== NAVIGATION HELPERS =====

  /**
   * Navigate to a URL and wait for page load
   */
  protected async navigateTo(url: string): Promise<void> {
    await this.page.goto(url);
    await this.page.waitForLoadState('networkidle');
  }

  /**
   * Navigate to a URL with authentication token
   */
  protected async navigateWithToken(url: string, token: string): Promise<void> {
    await this.page.goto(`${url}?auth_token=${token}`);
    await this.page.waitForLoadState('networkidle');
  }

  // ===== INTERACTION HELPERS =====

  /**
   * Clear and fill an input field
   */
  protected async fillInput(locator: Locator, value: string): Promise<void> {
    await locator.clear();
    await locator.fill(value);
  }

  /**
   * Click an element and optionally wait for another element
   */
  protected async clickAndWait(locator: Locator, waitForSelector?: string): Promise<void> {
    await locator.click();
    if (waitForSelector) {
      await this.page.waitForSelector(waitForSelector);
    }
  }

  // ===== WAIT HELPERS =====

  /**
   * Wait for an element to appear
   */
  protected async waitForElement(selector: string, timeout = 10000): Promise<void> {
    await this.page.waitForSelector(selector, { timeout });
  }

  /**
   * Wait for network to be idle
   */
  protected async waitForNetworkIdle(): Promise<void> {
    await this.page.waitForLoadState('networkidle');
  }

  // ===== GETTER HELPERS =====

  /**
   * Get text content of an element
   */
  protected async getText(locator: Locator): Promise<string> {
    return await locator.textContent() || '';
  }

  /**
   * Check if an element is visible
   */
  protected async isVisible(locator: Locator): Promise<boolean> {
    return await locator.isVisible();
  }

  // ===== VALIDATION HELPERS =====

  /**
   * Wait for element to be visible
   */
  protected async expectElementVisible(locator: Locator): Promise<void> {
    await locator.waitFor({ state: 'visible' });
  }

  /**
   * Wait for element to be hidden
   */
  protected async expectElementHidden(locator: Locator): Promise<void> {
    await locator.waitFor({ state: 'hidden' });
  }
}
```

### Custom BasePage (if configured)

**If team specifies custom BasePage:**
```
✓ Using custom BasePage: ./utils/custom-base-page.ts
✓ Custom BasePage will be imported by page objects
✓ Skipping BasePage generation (using existing)
```

---

## Step 3: Generate Page Object Classes

### For Each Page from Exploration

Generate one POM class per page following this structure:

**Generation steps:**
1. Create class file
2. Add imports (Playwright, BasePage)
3. Generate SELECTORS object with groups
4. Define public locators for assertions
5. Create constructor with locator initialization
6. Add navigation methods
7. Generate action methods based on element types
8. Generate getter methods for data retrieval
9. Generate wait condition methods
10. Add comprehensive documentation

### Example: Login Page Generation

```
✓ Generating LoginPage.ts...
✓ Importing BasePage
✓ Creating SELECTORS object with 3 groups
✓ Defining 4 public locators for assertions
✓ Creating constructor with locator initialization
✓ Adding navigation method
✓ Adding 5 action methods (login, loginWithRememberMe, etc.)
✓ Adding 3 getter methods (getErrorMessage, isLoginButtonEnabled, etc.)
✓ Adding 3 wait condition methods
✓ File saved: automated-tests/pom/LoginPage.ts
```

### Generated POM Structure

```typescript
import { Page, Locator } from '@playwright/test';
import { BasePage } from './BasePage';

/**
 * LoginPage - Represents the application login page
 *
 * URL: /login
 * Purpose: Handles user authentication functionality
 *
 * Common actions:
 * - login(username, password): Authenticates user with credentials
 * - loginWithRememberMe(username, password): Authenticates with remember me option
 * - clickForgotPassword(): Navigates to password reset flow
 *
 * Source: features/user-auth/feature-knowledge.md > User Authentication
 * Generated: 2025-12-02 by /automate-testcases
 * Standards: @qa-agent-os/standards/automation/pom-patterns.md
 */
export class LoginPage extends BasePage {
  // SELECTORS: Define all element selectors grouped by functionality
  private readonly SELECTORS = {
    form: {
      usernameInput: '[data-testid="username-input"]',  // Priority: data-testid
      passwordInput: '#password',                        // Priority: id
      rememberMeCheckbox: '[data-testid="remember-me"]',
      submitButton: 'button:has-text("Sign In")'        // Complex: Multiple buttons, text distinguishes
    },
    messages: {
      errorMessage: '.error-message',                    // Priority: semantic class
      successMessage: '.success-message'
    },
    links: {
      forgotPassword: 'a[href="/forgot-password"]',
      signUp: '[data-testid="signup-link"]'
    }
  };

  // PUBLIC LOCATORS: Exposed for test assertions
  readonly errorMessage: Locator;
  readonly successMessage: Locator;
  readonly submitButton: Locator;

  constructor(page: Page) {
    super(page);

    // Initialize public locators
    this.errorMessage = page.locator(this.SELECTORS.messages.errorMessage);
    this.successMessage = page.locator(this.SELECTORS.messages.successMessage);
    this.submitButton = page.locator(this.SELECTORS.form.submitButton);
  }

  // NAVIGATION METHODS

  /**
   * Navigate to the login page
   */
  async navigate(): Promise<void> {
    await this.navigateTo('/login');
    await this.waitForPageLoad();
  }

  // ACTION METHODS: Represent user interactions

  /**
   * Log in with username and password
   *
   * @param username - User's email or username
   * @param password - User's password
   */
  async login(username: string, password: string): Promise<void> {
    await this.fillInput(
      this.page.locator(this.SELECTORS.form.usernameInput),
      username
    );
    await this.fillInput(
      this.page.locator(this.SELECTORS.form.passwordInput),
      password
    );
    await this.page.locator(this.SELECTORS.form.submitButton).click();
  }

  /**
   * Log in with username, password, and remember me option
   *
   * @param username - User's email or username
   * @param password - User's password
   */
  async loginWithRememberMe(username: string, password: string): Promise<void> {
    await this.fillInput(
      this.page.locator(this.SELECTORS.form.usernameInput),
      username
    );
    await this.fillInput(
      this.page.locator(this.SELECTORS.form.passwordInput),
      password
    );
    await this.page.locator(this.SELECTORS.form.rememberMeCheckbox).check();
    await this.page.locator(this.SELECTORS.form.submitButton).click();
  }

  /**
   * Click forgot password link
   */
  async clickForgotPassword(): Promise<void> {
    await this.page.locator(this.SELECTORS.links.forgotPassword).click();
  }

  /**
   * Click sign up link
   */
  async clickSignUp(): Promise<void> {
    await this.page.locator(this.SELECTORS.links.signUp).click();
  }

  /**
   * Clear the login form
   */
  async clearForm(): Promise<void> {
    await this.page.locator(this.SELECTORS.form.usernameInput).clear();
    await this.page.locator(this.SELECTORS.form.passwordInput).clear();
  }

  // GETTER METHODS: Retrieve page state/data

  /**
   * Get the error message text
   *
   * @returns Error message content or empty string if not present
   */
  async getErrorMessage(): Promise<string> {
    return await this.getText(this.errorMessage);
  }

  /**
   * Check if login button is enabled
   *
   * @returns True if button is enabled, false otherwise
   */
  async isLoginButtonEnabled(): Promise<boolean> {
    return await this.submitButton.isEnabled();
  }

  /**
   * Check if remember me is checked
   *
   * @returns True if checkbox is checked, false otherwise
   */
  async isRememberMeChecked(): Promise<boolean> {
    return await this.page.locator(this.SELECTORS.form.rememberMeCheckbox).isChecked();
  }

  // WAIT CONDITION METHODS

  /**
   * Wait for error message to appear
   */
  async waitForErrorMessage(): Promise<void> {
    await this.errorMessage.waitFor({ state: 'visible' });
  }

  /**
   * Wait for success message to appear
   */
  async waitForSuccessMessage(): Promise<void> {
    await this.successMessage.waitFor({ state: 'visible' });
  }

  /**
   * Wait for login page to fully load
   */
  private async waitForPageLoad(): Promise<void> {
    await this.page.waitForSelector(this.SELECTORS.form.usernameInput);
  }
}
```

---

## Step 4: Method Generation Logic

### Action Methods (Based on Element Types)

**Generation rules:**

**Input fields → fill[FieldName]() or combined methods**
```typescript
// Single field
async fillUsername(username: string): Promise<void> {
  await this.fillInput(this.usernameInput, username);
}

// Combined (preferred for forms)
async login(username: string, password: string): Promise<void> {
  await this.fillInput(this.usernameInput, username);
  await this.fillInput(this.passwordInput, password);
  await this.submitButton.click();
}
```

**Buttons → click[ButtonName]() or action verbs**
```typescript
async clickSubmit(): Promise<void> {
  await this.submitButton.click();
}

// Better: Use action verb
async submit(): Promise<void> {
  await this.submitButton.click();
}
```

**Checkboxes → check/uncheck[CheckboxName]()**
```typescript
async checkRememberMe(): Promise<void> {
  await this.rememberMeCheckbox.check();
}

async uncheckRememberMe(): Promise<void> {
  await this.rememberMeCheckbox.uncheck();
}
```

**Dropdowns → select[DropdownName]()**
```typescript
async selectCountry(country: string): Promise<void> {
  await this.countryDropdown.selectOption(country);
}
```

**Links → click[LinkName]() or navigate actions**
```typescript
async clickForgotPassword(): Promise<void> {
  await this.forgotPasswordLink.click();
}
```

### Getter Methods (Based on Element Purposes)

**Text elements → get[ElementName]Text()**
```typescript
async getErrorMessage(): Promise<string> {
  return await this.errorMessage.textContent() || '';
}
```

**State checks → is[ElementName]Visible/Enabled/Checked()**
```typescript
async isLoginButtonEnabled(): Promise<boolean> {
  return await this.submitButton.isEnabled();
}

async isErrorMessageVisible(): Promise<boolean> {
  return await this.errorMessage.isVisible();
}

async isRememberMeChecked(): Promise<boolean> {
  return await this.rememberMeCheckbox.isChecked();
}
```

**Data retrieval → get[DataName]()**
```typescript
async getUserCount(): Promise<number> {
  const text = await this.userCountElement.textContent() || '0';
  return parseInt(text);
}
```

### Wait Methods

**Visibility waits → waitFor[ElementName]()**
```typescript
async waitForErrorMessage(): Promise<void> {
  await this.errorMessage.waitFor({ state: 'visible' });
}

async waitForDashboard(): Promise<void> {
  await this.page.waitForURL(/\/dashboard/);
}
```

**Page load waits → private waitForPageLoad()**
```typescript
private async waitForPageLoad(): Promise<void> {
  await this.page.waitForSelector(this.SELECTORS.form.usernameInput);
  await this.waitForNetworkIdle();
}
```

---

## Step 5: Verify Selectors Against Live DOM

### Re-verification Process

After POM generation, re-verify all selectors against live DOM:

```
✓ Verifying LoginPage selectors...
✓ Testing: [data-testid="username-input"] → Found ✓
✓ Testing: #password → Found ✓
✓ Testing: button:has-text("Sign In") → Found ✓
✓ Testing: .error-message → Found (initially hidden) ✓
✓ All LoginPage selectors verified

✓ Verifying DashboardPage selectors...
✓ Testing: [data-testid="user-name"] → Found ✓
✓ Testing: [data-testid="logout"] → Found ✓
✓ All DashboardPage selectors verified

✓ All POM selectors verified against live DOM
```

**If selector fails verification:**
```
⚠️  Selector verification failed: .submit-button

Element not found on page. Possible issues:
  - Element is conditionally rendered
  - Selector changed since exploration
  - Element requires interaction to appear

Action taken:
  ✓ Using fallback selector: button[type="submit"]
  ✓ Added comment explaining selector choice
  ✓ Marked for manual verification in README
```

---

## Step 6: Apply Standards Compliance

### Standards Checklist

Verify generated POMs against standards:

```
✓ Verifying standards compliance...
✓ Checking: All classes extend BasePage
✓ Checking: Selectors in SELECTORS object
✓ Checking: Selector priority followed
✓ Checking: Public locators for assertions
✓ Checking: Method naming conventions
✓ Checking: No hardcoded values
✓ Checking: Documentation comments present
✓ Checking: Error handling follows patterns
✓ All standards checks passed
```

**Standards enforced:**
- `@qa-agent-os/standards/automation/pom-patterns.md` - POM structure
- `@qa-agent-os/standards/global/coding-style.md` - TypeScript conventions
- `@qa-agent-os/standards/global/commenting.md` - Documentation requirements

**If standards violation detected:**
```
⚠️  Standards violation: Hardcoded URL in navigation method

Expected: await this.navigateTo('/login');
Found: await this.page.goto('http://localhost:3000/login');

Action taken:
  ✓ Corrected to use relative URL
  ✓ Added comment referencing standards
```

---

## Step 7: Generate Component Page Objects

### Identify Reusable Components

Analyze elements across pages to identify reusable components:

```
✓ Analyzing for reusable components...
✓ Found: Modal dialogs on 3 pages (Dashboard, Profile, Settings)
✓ Found: Navigation menu on all pages
✓ Found: Search bar on multiple pages
✓ Generating 3 component page objects...
```

**Component identification criteria:**
- Appears on 2+ pages
- Has consistent structure and behavior
- Logically separable unit
- Examples: modals, navigation, forms, tables

### Component POM Structure

**Example: ModalComponent**

```typescript
import { Page, Locator } from '@playwright/test';
import { BasePage } from '../BasePage';

/**
 * ModalComponent - Represents reusable modal dialog
 *
 * Used on: Dashboard, Profile, Settings pages
 * Purpose: Common modal interaction patterns
 *
 * Generated: 2025-12-02 by /automate-testcases
 * Standards: @qa-agent-os/standards/automation/pom-patterns.md
 */
export class ModalComponent extends BasePage {
  private readonly SELECTORS = {
    container: '.modal-overlay',
    dialog: '[role="dialog"]',
    title: '.modal-title',
    closeButton: '[data-testid="modal-close"]',
    confirmButton: '[data-testid="modal-confirm"]',
    cancelButton: '[data-testid="modal-cancel"]'
  };

  readonly title: Locator;
  readonly confirmButton: Locator;

  constructor(page: Page) {
    super(page);
    this.title = page.locator(this.SELECTORS.title);
    this.confirmButton = page.locator(this.SELECTORS.confirmButton);
  }

  async waitForModal(): Promise<void> {
    await this.page.locator(this.SELECTORS.container).waitFor({ state: 'visible' });
  }

  async close(): Promise<void> {
    await this.page.locator(this.SELECTORS.closeButton).click();
    await this.page.locator(this.SELECTORS.container).waitFor({ state: 'hidden' });
  }

  async confirm(): Promise<void> {
    await this.confirmButton.click();
  }

  async cancel(): Promise<void> {
    await this.page.locator(this.SELECTORS.cancelButton).click();
  }

  async getTitle(): Promise<string> {
    return await this.getText(this.title);
  }
}
```

**Component saved to:** `automated-tests/pom/components/ModalComponent.ts`

---

## Step 8: Validate Generated POMs

### TypeScript Compilation Check

```
✓ Checking TypeScript syntax...
✓ All imports valid
✓ All type definitions correct
✓ No compilation errors
✓ POMs ready for use
```

**If TypeScript errors found:**
```
❌ TypeScript compilation errors:

  LoginPage.ts:45:12 - error TS2345: Argument of type 'string | null'
  is not assignable to parameter of type 'string'.

Action taken:
  ✓ Fixed with null coalescing operator
  ✓ Re-validated TypeScript
  ✓ All errors resolved
```

---

## Step 9: POM Generation Summary

```
════════════════════════════════════════════════════════════
  POM Generation Summary
════════════════════════════════════════════════════════════

Generated Page Objects: 4

BasePage.ts
  ├── Navigation helpers: 2 methods
  ├── Interaction helpers: 2 methods
  ├── Wait helpers: 2 methods
  ├── Getter helpers: 2 methods
  └── Validation helpers: 2 methods

LoginPage.ts
  ├── Selectors: 8 elements in 3 groups
  ├── Action methods: 5 methods
  ├── Getter methods: 3 methods
  ├── Wait methods: 3 methods
  └── All selectors verified ✓

DashboardPage.ts
  ├── Selectors: 15 elements in 3 groups
  ├── Action methods: 8 methods
  ├── Getter methods: 5 methods
  ├── Wait methods: 4 methods
  └── All selectors verified ✓

ProfilePage.ts
  ├── Selectors: 8 elements in 2 groups
  ├── Action methods: 6 methods
  ├── Getter methods: 4 methods
  ├── Wait methods: 2 methods
  └── All selectors verified ✓

Components:
  ├── ModalComponent.ts
  └── NavigationComponent.ts

Standards Compliance: 100% ✓
Selector Quality: Excellent (80% data-testid/id)
Documentation: Complete ✓
TypeScript Compilation: Success ✓

Files saved to: automated-tests/pom/

════════════════════════════════════════════════════════════
```

---

## Error Handling

### Common Issues

**1. Selector Not Found During Verification**
```
⚠️  Selector not found: [data-testid="submit-button"]

Attempting fallback:
  ✓ Trying: button[type="submit"]
  ✓ Found with fallback selector
  ✓ Updated POM with fallback and comment
```

**2. Method Generation Ambiguity**
```
⚠️  Multiple buttons with same purpose detected

Original: clickButton()
Refined: clickSubmitButton(), clickCancelButton()

✓ Methods disambiguated with clearer names
```

**3. Import Path Issues**
```
⚠️  Import path may be incorrect: ../BasePage

Validating:
  ✓ Checking relative path from pom/LoginPage.ts
  ✓ Correct path: ./BasePage
  ✓ Import path corrected
```

---

## Standards Reference

**POM Standards:**
- `@qa-agent-os/standards/automation/pom-patterns.md` - POM construction standards

**Global Standards:**
- `@qa-agent-os/standards/global/coding-style.md` - TypeScript conventions
- `@qa-agent-os/standards/global/commenting.md` - Documentation standards
- `@qa-agent-os/standards/global/error-handling.md` - Error handling patterns

**Playwright Resources:**
- Page Object Model: https://playwright.dev/docs/pom
- Locators: https://playwright.dev/docs/locators
- Best Practices: https://playwright.dev/docs/best-practices

---

*This workflow ensures high-quality, maintainable Page Object Model classes that follow team patterns and industry best practices.*
